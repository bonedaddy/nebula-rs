// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `nebula.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct NebulaMeta {
    // message fields
    pub Type: NebulaMeta_MessageType,
    pub Details: ::protobuf::SingularPtrField<NebulaMetaDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NebulaMeta {
    fn default() -> &'a NebulaMeta {
        <NebulaMeta as ::protobuf::Message>::default_instance()
    }
}

impl NebulaMeta {
    pub fn new() -> NebulaMeta {
        ::std::default::Default::default()
    }

    // .nebula.NebulaMeta.MessageType Type = 1;


    pub fn get_Type(&self) -> NebulaMeta_MessageType {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = NebulaMeta_MessageType::None;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: NebulaMeta_MessageType) {
        self.Type = v;
    }

    // .nebula.NebulaMetaDetails Details = 2;


    pub fn get_Details(&self) -> &NebulaMetaDetails {
        self.Details.as_ref().unwrap_or_else(|| <NebulaMetaDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Details(&mut self) {
        self.Details.clear();
    }

    pub fn has_Details(&self) -> bool {
        self.Details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Details(&mut self, v: NebulaMetaDetails) {
        self.Details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Details(&mut self) -> &mut NebulaMetaDetails {
        if self.Details.is_none() {
            self.Details.set_default();
        }
        self.Details.as_mut().unwrap()
    }

    // Take field
    pub fn take_Details(&mut self) -> NebulaMetaDetails {
        self.Details.take().unwrap_or_else(|| NebulaMetaDetails::new())
    }
}

impl ::protobuf::Message for NebulaMeta {
    fn is_initialized(&self) -> bool {
        for v in &self.Details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != NebulaMeta_MessageType::None {
            my_size += ::protobuf::rt::enum_size(1, self.Type);
        }
        if let Some(ref v) = self.Details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Type != NebulaMeta_MessageType::None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.Type))?;
        }
        if let Some(ref v) = self.Details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NebulaMeta {
        NebulaMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NebulaMeta_MessageType>>(
                "Type",
                |m: &NebulaMeta| { &m.Type },
                |m: &mut NebulaMeta| { &mut m.Type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NebulaMetaDetails>>(
                "Details",
                |m: &NebulaMeta| { &m.Details },
                |m: &mut NebulaMeta| { &mut m.Details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NebulaMeta>(
                "NebulaMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NebulaMeta {
        static instance: ::protobuf::rt::LazyV2<NebulaMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NebulaMeta::new)
    }
}

impl ::protobuf::Clear for NebulaMeta {
    fn clear(&mut self) {
        self.Type = NebulaMeta_MessageType::None;
        self.Details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NebulaMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NebulaMeta_MessageType {
    None = 0,
    HostQuery = 1,
    HostQueryReply = 2,
    HostUpdateNotification = 3,
    HostMovedNotification = 4,
    HostPunchNotification = 5,
    HostWhoami = 6,
    HostWhoamiReply = 7,
    PathCheck = 8,
    PathCheckReply = 9,
}

impl ::protobuf::ProtobufEnum for NebulaMeta_MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NebulaMeta_MessageType> {
        match value {
            0 => ::std::option::Option::Some(NebulaMeta_MessageType::None),
            1 => ::std::option::Option::Some(NebulaMeta_MessageType::HostQuery),
            2 => ::std::option::Option::Some(NebulaMeta_MessageType::HostQueryReply),
            3 => ::std::option::Option::Some(NebulaMeta_MessageType::HostUpdateNotification),
            4 => ::std::option::Option::Some(NebulaMeta_MessageType::HostMovedNotification),
            5 => ::std::option::Option::Some(NebulaMeta_MessageType::HostPunchNotification),
            6 => ::std::option::Option::Some(NebulaMeta_MessageType::HostWhoami),
            7 => ::std::option::Option::Some(NebulaMeta_MessageType::HostWhoamiReply),
            8 => ::std::option::Option::Some(NebulaMeta_MessageType::PathCheck),
            9 => ::std::option::Option::Some(NebulaMeta_MessageType::PathCheckReply),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NebulaMeta_MessageType] = &[
            NebulaMeta_MessageType::None,
            NebulaMeta_MessageType::HostQuery,
            NebulaMeta_MessageType::HostQueryReply,
            NebulaMeta_MessageType::HostUpdateNotification,
            NebulaMeta_MessageType::HostMovedNotification,
            NebulaMeta_MessageType::HostPunchNotification,
            NebulaMeta_MessageType::HostWhoami,
            NebulaMeta_MessageType::HostWhoamiReply,
            NebulaMeta_MessageType::PathCheck,
            NebulaMeta_MessageType::PathCheckReply,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NebulaMeta_MessageType>("NebulaMeta.MessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NebulaMeta_MessageType {
}

impl ::std::default::Default for NebulaMeta_MessageType {
    fn default() -> Self {
        NebulaMeta_MessageType::None
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaMeta_MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NebulaMetaDetails {
    // message fields
    pub VpnIp: u32,
    pub Ip4AndPorts: ::protobuf::RepeatedField<Ip4AndPort>,
    pub Ip6AndPorts: ::protobuf::RepeatedField<Ip6AndPort>,
    pub counter: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NebulaMetaDetails {
    fn default() -> &'a NebulaMetaDetails {
        <NebulaMetaDetails as ::protobuf::Message>::default_instance()
    }
}

impl NebulaMetaDetails {
    pub fn new() -> NebulaMetaDetails {
        ::std::default::Default::default()
    }

    // uint32 VpnIp = 1;


    pub fn get_VpnIp(&self) -> u32 {
        self.VpnIp
    }
    pub fn clear_VpnIp(&mut self) {
        self.VpnIp = 0;
    }

    // Param is passed by value, moved
    pub fn set_VpnIp(&mut self, v: u32) {
        self.VpnIp = v;
    }

    // repeated .nebula.Ip4AndPort Ip4AndPorts = 2;


    pub fn get_Ip4AndPorts(&self) -> &[Ip4AndPort] {
        &self.Ip4AndPorts
    }
    pub fn clear_Ip4AndPorts(&mut self) {
        self.Ip4AndPorts.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ip4AndPorts(&mut self, v: ::protobuf::RepeatedField<Ip4AndPort>) {
        self.Ip4AndPorts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ip4AndPorts(&mut self) -> &mut ::protobuf::RepeatedField<Ip4AndPort> {
        &mut self.Ip4AndPorts
    }

    // Take field
    pub fn take_Ip4AndPorts(&mut self) -> ::protobuf::RepeatedField<Ip4AndPort> {
        ::std::mem::replace(&mut self.Ip4AndPorts, ::protobuf::RepeatedField::new())
    }

    // repeated .nebula.Ip6AndPort Ip6AndPorts = 4;


    pub fn get_Ip6AndPorts(&self) -> &[Ip6AndPort] {
        &self.Ip6AndPorts
    }
    pub fn clear_Ip6AndPorts(&mut self) {
        self.Ip6AndPorts.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ip6AndPorts(&mut self, v: ::protobuf::RepeatedField<Ip6AndPort>) {
        self.Ip6AndPorts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ip6AndPorts(&mut self) -> &mut ::protobuf::RepeatedField<Ip6AndPort> {
        &mut self.Ip6AndPorts
    }

    // Take field
    pub fn take_Ip6AndPorts(&mut self) -> ::protobuf::RepeatedField<Ip6AndPort> {
        ::std::mem::replace(&mut self.Ip6AndPorts, ::protobuf::RepeatedField::new())
    }

    // uint32 counter = 3;


    pub fn get_counter(&self) -> u32 {
        self.counter
    }
    pub fn clear_counter(&mut self) {
        self.counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u32) {
        self.counter = v;
    }
}

impl ::protobuf::Message for NebulaMetaDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.Ip4AndPorts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Ip6AndPorts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.VpnIp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Ip4AndPorts)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Ip6AndPorts)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.counter = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.VpnIp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.VpnIp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Ip4AndPorts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Ip6AndPorts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.counter != 0 {
            my_size += ::protobuf::rt::value_size(3, self.counter, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.VpnIp != 0 {
            os.write_uint32(1, self.VpnIp)?;
        }
        for v in &self.Ip4AndPorts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Ip6AndPorts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.counter != 0 {
            os.write_uint32(3, self.counter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NebulaMetaDetails {
        NebulaMetaDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "VpnIp",
                |m: &NebulaMetaDetails| { &m.VpnIp },
                |m: &mut NebulaMetaDetails| { &mut m.VpnIp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ip4AndPort>>(
                "Ip4AndPorts",
                |m: &NebulaMetaDetails| { &m.Ip4AndPorts },
                |m: &mut NebulaMetaDetails| { &mut m.Ip4AndPorts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ip6AndPort>>(
                "Ip6AndPorts",
                |m: &NebulaMetaDetails| { &m.Ip6AndPorts },
                |m: &mut NebulaMetaDetails| { &mut m.Ip6AndPorts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "counter",
                |m: &NebulaMetaDetails| { &m.counter },
                |m: &mut NebulaMetaDetails| { &mut m.counter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NebulaMetaDetails>(
                "NebulaMetaDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NebulaMetaDetails {
        static instance: ::protobuf::rt::LazyV2<NebulaMetaDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NebulaMetaDetails::new)
    }
}

impl ::protobuf::Clear for NebulaMetaDetails {
    fn clear(&mut self) {
        self.VpnIp = 0;
        self.Ip4AndPorts.clear();
        self.Ip6AndPorts.clear();
        self.counter = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NebulaMetaDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaMetaDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ip4AndPort {
    // message fields
    pub Ip: u32,
    pub Port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ip4AndPort {
    fn default() -> &'a Ip4AndPort {
        <Ip4AndPort as ::protobuf::Message>::default_instance()
    }
}

impl Ip4AndPort {
    pub fn new() -> Ip4AndPort {
        ::std::default::Default::default()
    }

    // uint32 Ip = 1;


    pub fn get_Ip(&self) -> u32 {
        self.Ip
    }
    pub fn clear_Ip(&mut self) {
        self.Ip = 0;
    }

    // Param is passed by value, moved
    pub fn set_Ip(&mut self, v: u32) {
        self.Ip = v;
    }

    // uint32 Port = 2;


    pub fn get_Port(&self) -> u32 {
        self.Port
    }
    pub fn clear_Port(&mut self) {
        self.Port = 0;
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: u32) {
        self.Port = v;
    }
}

impl ::protobuf::Message for Ip4AndPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Ip = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Ip != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Ip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Ip != 0 {
            os.write_uint32(1, self.Ip)?;
        }
        if self.Port != 0 {
            os.write_uint32(2, self.Port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ip4AndPort {
        Ip4AndPort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Ip",
                |m: &Ip4AndPort| { &m.Ip },
                |m: &mut Ip4AndPort| { &mut m.Ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Port",
                |m: &Ip4AndPort| { &m.Port },
                |m: &mut Ip4AndPort| { &mut m.Port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ip4AndPort>(
                "Ip4AndPort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ip4AndPort {
        static instance: ::protobuf::rt::LazyV2<Ip4AndPort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ip4AndPort::new)
    }
}

impl ::protobuf::Clear for Ip4AndPort {
    fn clear(&mut self) {
        self.Ip = 0;
        self.Port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ip4AndPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ip4AndPort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ip6AndPort {
    // message fields
    pub Hi: u64,
    pub Lo: u64,
    pub Port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ip6AndPort {
    fn default() -> &'a Ip6AndPort {
        <Ip6AndPort as ::protobuf::Message>::default_instance()
    }
}

impl Ip6AndPort {
    pub fn new() -> Ip6AndPort {
        ::std::default::Default::default()
    }

    // uint64 Hi = 1;


    pub fn get_Hi(&self) -> u64 {
        self.Hi
    }
    pub fn clear_Hi(&mut self) {
        self.Hi = 0;
    }

    // Param is passed by value, moved
    pub fn set_Hi(&mut self, v: u64) {
        self.Hi = v;
    }

    // uint64 Lo = 2;


    pub fn get_Lo(&self) -> u64 {
        self.Lo
    }
    pub fn clear_Lo(&mut self) {
        self.Lo = 0;
    }

    // Param is passed by value, moved
    pub fn set_Lo(&mut self, v: u64) {
        self.Lo = v;
    }

    // uint32 Port = 3;


    pub fn get_Port(&self) -> u32 {
        self.Port
    }
    pub fn clear_Port(&mut self) {
        self.Port = 0;
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: u32) {
        self.Port = v;
    }
}

impl ::protobuf::Message for Ip6AndPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Hi = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Lo = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Hi != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Hi, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Lo != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Lo, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Hi != 0 {
            os.write_uint64(1, self.Hi)?;
        }
        if self.Lo != 0 {
            os.write_uint64(2, self.Lo)?;
        }
        if self.Port != 0 {
            os.write_uint32(3, self.Port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ip6AndPort {
        Ip6AndPort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Hi",
                |m: &Ip6AndPort| { &m.Hi },
                |m: &mut Ip6AndPort| { &mut m.Hi },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Lo",
                |m: &Ip6AndPort| { &m.Lo },
                |m: &mut Ip6AndPort| { &mut m.Lo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Port",
                |m: &Ip6AndPort| { &m.Port },
                |m: &mut Ip6AndPort| { &mut m.Port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ip6AndPort>(
                "Ip6AndPort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ip6AndPort {
        static instance: ::protobuf::rt::LazyV2<Ip6AndPort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ip6AndPort::new)
    }
}

impl ::protobuf::Clear for Ip6AndPort {
    fn clear(&mut self) {
        self.Hi = 0;
        self.Lo = 0;
        self.Port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ip6AndPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ip6AndPort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NebulaPing {
    // message fields
    pub Type: NebulaPing_MessageType,
    pub Time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NebulaPing {
    fn default() -> &'a NebulaPing {
        <NebulaPing as ::protobuf::Message>::default_instance()
    }
}

impl NebulaPing {
    pub fn new() -> NebulaPing {
        ::std::default::Default::default()
    }

    // .nebula.NebulaPing.MessageType Type = 1;


    pub fn get_Type(&self) -> NebulaPing_MessageType {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = NebulaPing_MessageType::Ping;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: NebulaPing_MessageType) {
        self.Type = v;
    }

    // uint64 Time = 2;


    pub fn get_Time(&self) -> u64 {
        self.Time
    }
    pub fn clear_Time(&mut self) {
        self.Time = 0;
    }

    // Param is passed by value, moved
    pub fn set_Time(&mut self, v: u64) {
        self.Time = v;
    }
}

impl ::protobuf::Message for NebulaPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != NebulaPing_MessageType::Ping {
            my_size += ::protobuf::rt::enum_size(1, self.Type);
        }
        if self.Time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Type != NebulaPing_MessageType::Ping {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.Type))?;
        }
        if self.Time != 0 {
            os.write_uint64(2, self.Time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NebulaPing {
        NebulaPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NebulaPing_MessageType>>(
                "Type",
                |m: &NebulaPing| { &m.Type },
                |m: &mut NebulaPing| { &mut m.Type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Time",
                |m: &NebulaPing| { &m.Time },
                |m: &mut NebulaPing| { &mut m.Time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NebulaPing>(
                "NebulaPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NebulaPing {
        static instance: ::protobuf::rt::LazyV2<NebulaPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NebulaPing::new)
    }
}

impl ::protobuf::Clear for NebulaPing {
    fn clear(&mut self) {
        self.Type = NebulaPing_MessageType::Ping;
        self.Time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NebulaPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NebulaPing_MessageType {
    Ping = 0,
    Reply = 1,
}

impl ::protobuf::ProtobufEnum for NebulaPing_MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NebulaPing_MessageType> {
        match value {
            0 => ::std::option::Option::Some(NebulaPing_MessageType::Ping),
            1 => ::std::option::Option::Some(NebulaPing_MessageType::Reply),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NebulaPing_MessageType] = &[
            NebulaPing_MessageType::Ping,
            NebulaPing_MessageType::Reply,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NebulaPing_MessageType>("NebulaPing.MessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NebulaPing_MessageType {
}

impl ::std::default::Default for NebulaPing_MessageType {
    fn default() -> Self {
        NebulaPing_MessageType::Ping
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaPing_MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NebulaHandshake {
    // message fields
    pub Details: ::protobuf::SingularPtrField<NebulaHandshakeDetails>,
    pub Hmac: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NebulaHandshake {
    fn default() -> &'a NebulaHandshake {
        <NebulaHandshake as ::protobuf::Message>::default_instance()
    }
}

impl NebulaHandshake {
    pub fn new() -> NebulaHandshake {
        ::std::default::Default::default()
    }

    // .nebula.NebulaHandshakeDetails Details = 1;


    pub fn get_Details(&self) -> &NebulaHandshakeDetails {
        self.Details.as_ref().unwrap_or_else(|| <NebulaHandshakeDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Details(&mut self) {
        self.Details.clear();
    }

    pub fn has_Details(&self) -> bool {
        self.Details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Details(&mut self, v: NebulaHandshakeDetails) {
        self.Details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Details(&mut self) -> &mut NebulaHandshakeDetails {
        if self.Details.is_none() {
            self.Details.set_default();
        }
        self.Details.as_mut().unwrap()
    }

    // Take field
    pub fn take_Details(&mut self) -> NebulaHandshakeDetails {
        self.Details.take().unwrap_or_else(|| NebulaHandshakeDetails::new())
    }

    // bytes Hmac = 2;


    pub fn get_Hmac(&self) -> &[u8] {
        &self.Hmac
    }
    pub fn clear_Hmac(&mut self) {
        self.Hmac.clear();
    }

    // Param is passed by value, moved
    pub fn set_Hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.Hmac = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Hmac
    }

    // Take field
    pub fn take_Hmac(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Hmac, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NebulaHandshake {
    fn is_initialized(&self) -> bool {
        for v in &self.Details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Details)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Hmac)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Hmac.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.Hmac);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Details.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Hmac.is_empty() {
            os.write_bytes(2, &self.Hmac)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NebulaHandshake {
        NebulaHandshake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NebulaHandshakeDetails>>(
                "Details",
                |m: &NebulaHandshake| { &m.Details },
                |m: &mut NebulaHandshake| { &mut m.Details },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "Hmac",
                |m: &NebulaHandshake| { &m.Hmac },
                |m: &mut NebulaHandshake| { &mut m.Hmac },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NebulaHandshake>(
                "NebulaHandshake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NebulaHandshake {
        static instance: ::protobuf::rt::LazyV2<NebulaHandshake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NebulaHandshake::new)
    }
}

impl ::protobuf::Clear for NebulaHandshake {
    fn clear(&mut self) {
        self.Details.clear();
        self.Hmac.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NebulaHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaHandshake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NebulaHandshakeDetails {
    // message fields
    pub Cert: ::std::vec::Vec<u8>,
    pub InitiatorIndex: u32,
    pub ResponderIndex: u32,
    pub Cookie: u64,
    pub Time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NebulaHandshakeDetails {
    fn default() -> &'a NebulaHandshakeDetails {
        <NebulaHandshakeDetails as ::protobuf::Message>::default_instance()
    }
}

impl NebulaHandshakeDetails {
    pub fn new() -> NebulaHandshakeDetails {
        ::std::default::Default::default()
    }

    // bytes Cert = 1;


    pub fn get_Cert(&self) -> &[u8] {
        &self.Cert
    }
    pub fn clear_Cert(&mut self) {
        self.Cert.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cert(&mut self, v: ::std::vec::Vec<u8>) {
        self.Cert = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cert(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Cert
    }

    // Take field
    pub fn take_Cert(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Cert, ::std::vec::Vec::new())
    }

    // uint32 InitiatorIndex = 2;


    pub fn get_InitiatorIndex(&self) -> u32 {
        self.InitiatorIndex
    }
    pub fn clear_InitiatorIndex(&mut self) {
        self.InitiatorIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_InitiatorIndex(&mut self, v: u32) {
        self.InitiatorIndex = v;
    }

    // uint32 ResponderIndex = 3;


    pub fn get_ResponderIndex(&self) -> u32 {
        self.ResponderIndex
    }
    pub fn clear_ResponderIndex(&mut self) {
        self.ResponderIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_ResponderIndex(&mut self, v: u32) {
        self.ResponderIndex = v;
    }

    // uint64 Cookie = 4;


    pub fn get_Cookie(&self) -> u64 {
        self.Cookie
    }
    pub fn clear_Cookie(&mut self) {
        self.Cookie = 0;
    }

    // Param is passed by value, moved
    pub fn set_Cookie(&mut self, v: u64) {
        self.Cookie = v;
    }

    // uint64 Time = 5;


    pub fn get_Time(&self) -> u64 {
        self.Time
    }
    pub fn clear_Time(&mut self) {
        self.Time = 0;
    }

    // Param is passed by value, moved
    pub fn set_Time(&mut self, v: u64) {
        self.Time = v;
    }
}

impl ::protobuf::Message for NebulaHandshakeDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Cert)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.InitiatorIndex = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ResponderIndex = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Cookie = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Cert.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.Cert);
        }
        if self.InitiatorIndex != 0 {
            my_size += ::protobuf::rt::value_size(2, self.InitiatorIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ResponderIndex != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ResponderIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Cookie != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Cookie, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.Time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Cert.is_empty() {
            os.write_bytes(1, &self.Cert)?;
        }
        if self.InitiatorIndex != 0 {
            os.write_uint32(2, self.InitiatorIndex)?;
        }
        if self.ResponderIndex != 0 {
            os.write_uint32(3, self.ResponderIndex)?;
        }
        if self.Cookie != 0 {
            os.write_uint64(4, self.Cookie)?;
        }
        if self.Time != 0 {
            os.write_uint64(5, self.Time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NebulaHandshakeDetails {
        NebulaHandshakeDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "Cert",
                |m: &NebulaHandshakeDetails| { &m.Cert },
                |m: &mut NebulaHandshakeDetails| { &mut m.Cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "InitiatorIndex",
                |m: &NebulaHandshakeDetails| { &m.InitiatorIndex },
                |m: &mut NebulaHandshakeDetails| { &mut m.InitiatorIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ResponderIndex",
                |m: &NebulaHandshakeDetails| { &m.ResponderIndex },
                |m: &mut NebulaHandshakeDetails| { &mut m.ResponderIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Cookie",
                |m: &NebulaHandshakeDetails| { &m.Cookie },
                |m: &mut NebulaHandshakeDetails| { &mut m.Cookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Time",
                |m: &NebulaHandshakeDetails| { &m.Time },
                |m: &mut NebulaHandshakeDetails| { &mut m.Time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NebulaHandshakeDetails>(
                "NebulaHandshakeDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NebulaHandshakeDetails {
        static instance: ::protobuf::rt::LazyV2<NebulaHandshakeDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NebulaHandshakeDetails::new)
    }
}

impl ::protobuf::Clear for NebulaHandshakeDetails {
    fn clear(&mut self) {
        self.Cert.clear();
        self.InitiatorIndex = 0;
        self.ResponderIndex = 0;
        self.Cookie = 0;
        self.Time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NebulaHandshakeDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NebulaHandshakeDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cnebula.proto\x12\x06nebula\"\xcc\x02\n\nNebulaMeta\x122\n\x04Type\
    \x18\x01\x20\x01(\x0e2\x1e.nebula.NebulaMeta.MessageTypeR\x04Type\x123\n\
    \x07Details\x18\x02\x20\x01(\x0b2\x19.nebula.NebulaMetaDetailsR\x07Detai\
    ls\"\xd4\x01\n\x0bMessageType\x12\x08\n\x04None\x10\0\x12\r\n\tHostQuery\
    \x10\x01\x12\x12\n\x0eHostQueryReply\x10\x02\x12\x1a\n\x16HostUpdateNoti\
    fication\x10\x03\x12\x19\n\x15HostMovedNotification\x10\x04\x12\x19\n\
    \x15HostPunchNotification\x10\x05\x12\x0e\n\nHostWhoami\x10\x06\x12\x13\
    \n\x0fHostWhoamiReply\x10\x07\x12\r\n\tPathCheck\x10\x08\x12\x12\n\x0ePa\
    thCheckReply\x10\t\"\xaf\x01\n\x11NebulaMetaDetails\x12\x14\n\x05VpnIp\
    \x18\x01\x20\x01(\rR\x05VpnIp\x124\n\x0bIp4AndPorts\x18\x02\x20\x03(\x0b\
    2\x12.nebula.Ip4AndPortR\x0bIp4AndPorts\x124\n\x0bIp6AndPorts\x18\x04\
    \x20\x03(\x0b2\x12.nebula.Ip6AndPortR\x0bIp6AndPorts\x12\x18\n\x07counte\
    r\x18\x03\x20\x01(\rR\x07counter\"0\n\nIp4AndPort\x12\x0e\n\x02Ip\x18\
    \x01\x20\x01(\rR\x02Ip\x12\x12\n\x04Port\x18\x02\x20\x01(\rR\x04Port\"@\
    \n\nIp6AndPort\x12\x0e\n\x02Hi\x18\x01\x20\x01(\x04R\x02Hi\x12\x0e\n\x02\
    Lo\x18\x02\x20\x01(\x04R\x02Lo\x12\x12\n\x04Port\x18\x03\x20\x01(\rR\x04\
    Port\"x\n\nNebulaPing\x122\n\x04Type\x18\x01\x20\x01(\x0e2\x1e.nebula.Ne\
    bulaPing.MessageTypeR\x04Type\x12\x12\n\x04Time\x18\x02\x20\x01(\x04R\
    \x04Time\"\"\n\x0bMessageType\x12\x08\n\x04Ping\x10\0\x12\t\n\x05Reply\
    \x10\x01\"_\n\x0fNebulaHandshake\x128\n\x07Details\x18\x01\x20\x01(\x0b2\
    \x1e.nebula.NebulaHandshakeDetailsR\x07Details\x12\x12\n\x04Hmac\x18\x02\
    \x20\x01(\x0cR\x04Hmac\"\xa8\x01\n\x16NebulaHandshakeDetails\x12\x12\n\
    \x04Cert\x18\x01\x20\x01(\x0cR\x04Cert\x12&\n\x0eInitiatorIndex\x18\x02\
    \x20\x01(\rR\x0eInitiatorIndex\x12&\n\x0eResponderIndex\x18\x03\x20\x01(\
    \rR\x0eResponderIndex\x12\x16\n\x06Cookie\x18\x04\x20\x01(\x04R\x06Cooki\
    e\x12\x12\n\x04Time\x18\x05\x20\x01(\x04R\x04TimeB\x1bZ\x19github.com/sl\
    ackhq/nebulaJ\xad\x0f\n\x06\x12\x04\0\0?\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x01\0\x0f\n\x08\n\x01\x08\x12\x03\x03\00\n\
    \t\n\x02\x08\x0b\x12\x03\x03\00\n\n\n\x02\x04\0\x12\x04\x05\0\x16\x01\n\
    \n\n\x03\x04\0\x01\x12\x03\x05\x08\x12\n\x0c\n\x04\x04\0\x04\0\x12\x04\
    \x06\x02\x12\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\x06\x07\x12\n\r\n\
    \x06\x04\0\x04\0\x02\0\x12\x03\x07\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x01\x12\x03\x07\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03\x07\
    \x0b\x0c\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03\x08\x04\x12\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x01\x12\x03\x08\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\
    \x01\x02\x12\x03\x08\x10\x11\n\r\n\x06\x04\0\x04\0\x02\x02\x12\x03\t\x04\
    \x17\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\t\x04\x12\n\x0e\n\x07\
    \x04\0\x04\0\x02\x02\x02\x12\x03\t\x15\x16\n\r\n\x06\x04\0\x04\0\x02\x03\
    \x12\x03\n\x04\x1f\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\x03\n\x04\x1a\
    \n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\n\x1d\x1e\n\r\n\x06\x04\0\
    \x04\0\x02\x04\x12\x03\x0b\x04\x1e\n\x0e\n\x07\x04\0\x04\0\x02\x04\x01\
    \x12\x03\x0b\x04\x19\n\x0e\n\x07\x04\0\x04\0\x02\x04\x02\x12\x03\x0b\x1c\
    \x1d\n\r\n\x06\x04\0\x04\0\x02\x05\x12\x03\x0c\x04\x1e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x05\x01\x12\x03\x0c\x04\x19\n\x0e\n\x07\x04\0\x04\0\x02\x05\
    \x02\x12\x03\x0c\x1c\x1d\n\r\n\x06\x04\0\x04\0\x02\x06\x12\x03\r\x04\x13\
    \n\x0e\n\x07\x04\0\x04\0\x02\x06\x01\x12\x03\r\x04\x0e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x06\x02\x12\x03\r\x11\x12\n\r\n\x06\x04\0\x04\0\x02\x07\x12\
    \x03\x0e\x04\x18\n\x0e\n\x07\x04\0\x04\0\x02\x07\x01\x12\x03\x0e\x04\x13\
    \n\x0e\n\x07\x04\0\x04\0\x02\x07\x02\x12\x03\x0e\x16\x17\n\r\n\x06\x04\0\
    \x04\0\x02\x08\x12\x03\x0f\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\x08\x01\
    \x12\x03\x0f\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x08\x02\x12\x03\x0f\x10\
    \x11\n\r\n\x06\x04\0\x04\0\x02\t\x12\x03\x10\x04\x17\n\x0e\n\x07\x04\0\
    \x04\0\x02\t\x01\x12\x03\x10\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\t\x02\
    \x12\x03\x10\x15\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\x14\x02\x17\n\x0c\n\
    \x05\x04\0\x02\0\x06\x12\x03\x14\x02\r\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x14\x0e\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x14\x15\x16\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x15\x02\x20\n\x0c\n\x05\x04\0\x02\x01\x06\x12\
    \x03\x15\x02\x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x15\x14\x1b\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03\x15\x1e\x1f\n\n\n\x02\x04\x01\x12\x04\
    \x18\0\x1d\x01\n\n\n\x03\x04\x01\x01\x12\x03\x18\x08\x19\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03\x19\x02\x13\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x19\
    \x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x19\t\x0e\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03\x19\x11\x12\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\
    \x1a\x02&\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x1a\x02\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x06\x12\x03\x1a\x0b\x15\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03\x1a\x16!\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1a$%\n\x0b\n\
    \x04\x04\x01\x02\x02\x12\x03\x1b\x02&\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03\x1b\x02\n\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03\x1b\x0b\x15\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x1b\x16!\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03\x1b$%\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x1c\x02\x15\n\
    \x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x03\x01\x12\x03\x1c\t\x10\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\
    \x1c\x13\x14\n\n\n\x02\x04\x02\x12\x04\x1f\0\"\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03\x1f\x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x20\x02\x10\n\x0c\
    \n\x05\x04\x02\x02\0\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03\x20\t\x0b\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x20\x0e\x0f\
    \n\x0b\n\x04\x04\x02\x02\x01\x12\x03!\x02\x12\n\x0c\n\x05\x04\x02\x02\
    \x01\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03!\t\r\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03!\x10\x11\n\n\n\x02\x04\x03\x12\
    \x04$\0(\x01\n\n\n\x03\x04\x03\x01\x12\x03$\x08\x12\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03%\x02\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03%\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03%\t\x0b\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03%\x0e\x0f\n\x0b\n\x04\x04\x03\x02\x01\x12\x03&\x02\x10\n\x0c\
    \n\x05\x04\x03\x02\x01\x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03&\t\x0b\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03&\x0e\x0f\n\
    \x0b\n\x04\x04\x03\x02\x02\x12\x03'\x02\x12\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03'\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03'\t\r\n\x0c\
    \n\x05\x04\x03\x02\x02\x03\x12\x03'\x10\x11\n\n\n\x02\x04\x04\x12\x04*\0\
    2\x01\n\n\n\x03\x04\x04\x01\x12\x03*\x08\x12\n\x0c\n\x04\x04\x04\x04\0\
    \x12\x04+\x02.\t\n\x0c\n\x05\x04\x04\x04\0\x01\x12\x03+\x07\x12\n\r\n\
    \x06\x04\x04\x04\0\x02\0\x12\x03,\x10\x19\n\x0e\n\x07\x04\x04\x04\0\x02\
    \0\x01\x12\x03,\x10\x14\n\x0e\n\x07\x04\x04\x04\0\x02\0\x02\x12\x03,\x17\
    \x18\n\r\n\x06\x04\x04\x04\0\x02\x01\x12\x03-\x10\x1a\n\x0e\n\x07\x04\
    \x04\x04\0\x02\x01\x01\x12\x03-\x10\x15\n\x0e\n\x07\x04\x04\x04\0\x02\
    \x01\x02\x12\x03-\x18\x19\n\x0b\n\x04\x04\x04\x02\0\x12\x030\x08\x1d\n\
    \x0c\n\x05\x04\x04\x02\0\x06\x12\x030\x08\x13\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x030\x14\x18\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x030\x1b\x1c\n\
    \x0b\n\x04\x04\x04\x02\x01\x12\x031\x08\x18\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x031\x08\x0e\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x031\x0f\x13\n\
    \x0c\n\x05\x04\x04\x02\x01\x03\x12\x031\x16\x17\n\n\n\x02\x04\x05\x12\
    \x044\07\x01\n\n\n\x03\x04\x05\x01\x12\x034\x08\x17\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x035\x02%\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x035\x02\x18\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x035\x19\x20\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x035#$\n\x0b\n\x04\x04\x05\x02\x01\x12\x036\x02\x11\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x036\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x036\x08\x0c\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x036\x0f\x10\n\n\n\
    \x02\x04\x06\x12\x049\0?\x01\n\n\n\x03\x04\x06\x01\x12\x039\x08\x1e\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03:\x02\x11\n\x0c\n\x05\x04\x06\x02\0\x05\
    \x12\x03:\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03:\x08\x0c\n\x0c\n\
    \x05\x04\x06\x02\0\x03\x12\x03:\x0f\x10\n\x0b\n\x04\x04\x06\x02\x01\x12\
    \x03;\x02\x1c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03;\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03;\t\x17\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03;\x1a\x1b\n\x0b\n\x04\x04\x06\x02\x02\x12\x03<\x02\x1c\n\x0c\n\
    \x05\x04\x06\x02\x02\x05\x12\x03<\x02\x08\n\x0c\n\x05\x04\x06\x02\x02\
    \x01\x12\x03<\t\x17\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03<\x1a\x1b\n\
    \x0b\n\x04\x04\x06\x02\x03\x12\x03=\x02\x14\n\x0c\n\x05\x04\x06\x02\x03\
    \x05\x12\x03=\x02\x08\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03=\t\x0f\n\
    \x0c\n\x05\x04\x06\x02\x03\x03\x12\x03=\x12\x13\n\x0b\n\x04\x04\x06\x02\
    \x04\x12\x03>\x02\x12\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03>\x02\x08\n\
    \x0c\n\x05\x04\x06\x02\x04\x01\x12\x03>\t\r\n\x0c\n\x05\x04\x06\x02\x04\
    \x03\x12\x03>\x10\x11b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
